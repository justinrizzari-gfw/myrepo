---
title: "Data training questions"
author: "Cian Luck"
date: "22 July 2021"
output:
  html_notebook:
    df_print: default
    highlight: pygments
    toc: yes
    toc_float:
      toc_collapsed: true
    toc_depth: 2
subtitle: Hannah's revamped training questions
editor_options:
  chunk_output_type: inline
---


<style>
body {
text-align: justify}
</style>

```{r setup, include = FALSE}
    knitr::opts_knit$set(root.dir = normalizePath("../..")) 
```

WORK IN PROGRESS

# Setup

Load packages
```{r, message=FALSE}
library(tidyverse)
library(bigrquery)
library(DBI)
library(fishwatchr)
library(glue)
library(lubridate)
library(here)
library(sf)
```


Establish connection to Big Query project
```{r}
con <- DBI::dbConnect(drv = bigrquery::bigquery(), 
                      project = "world-fishing-827", 
                      use_legacy_sql = FALSE)
```


# Transhipment inspection

## 1. How many encounter events did 'CHITOSE' have with fishing vessels in the first six months of 2021?

```{r}
query_6 <- glue_sql(
  "
-----------------------------------------------
-- Query: How many encounter events did CHITOSE have 
-- with fishing vessels in the first six months of
-- 2021
-----------------------------------------------

-- Cian Luck, Updated 23 Aug 2021

-- Based on example query:
#standardSQL
  -- Matching Encounter data to SSVID values
  -- Hannah Linder, Updated August 31,2020
  --
  -- This query can be used to get ssvid values (generally called MMSIs) matched to the encounter data, specifing both time and lat/lon range
  -- Then this query places the two encounter vessels on the same row of data for easy data management


-----------------------------------------------
-- Specify date range
-----------------------------------------------
---SET your date minimum of interest
CREATE TEMP FUNCTION minimum() AS (DATE('2021-01-01'));

---SET your date maximum of interest
CREATE TEMP FUNCTION maximum() AS (DATE('2021-06-30'));

WITH

-----------------------------------------------
-- vessel info
-----------------------------------------------
    vessel_info_chitose AS (
    SELECT 
        ssvid,
        year,
        ais_identity.n_shipname_mostcommon.value AS shipname,
        ais_identity.n_shipname_mostcommon.count AS shipname_count,
        best.best_flag AS flag,
        best.best_vessel_class AS vessel_class,
        on_fishing_list_best
    FROM 
        `world-fishing-827.gfw_research.vi_ssvid_byyear_v20210706`
    WHERE 
        'CHITOSE' IN (ais_identity.n_shipname_mostcommon.value)
        AND year = 2021),

-----------------------------------------------
 -- Retrieve initial encounter data, specifing time range and lat/lon
 -- JSON_EXTRACT is used to seperate the listed event_info data of interest into separate columns
 -----------------------------------------------
    encounters AS (
    SELECT
        event_id,
        vessel_id,
        event_start,
        event_end,
        lat_mean,
        lon_mean,
        JSON_EXTRACT(event_info,
        '$.median_distance_km') AS median_distance_km,
        JSON_EXTRACT(event_info,
        '$.median_speed_knots') AS median_speed_knots,
        -- extract the ssvid for both vessels involved in encounter
        JSON_VALUE(event_vessels,
        '$[0].ssvid') AS ssvid_a,
        JSON_VALUE(event_vessels,
        '$[1].ssvid') AS ssvid_b,
    SPLIT(event_id, '.')[ORDINAL(1)] AS event,
    CAST (event_start AS DATE) event_date,
    EXTRACT(YEAR FROM event_start) AS year
    FROM
    `world-fishing-827.pipe_production_v20201001.published_events_encounters`
    WHERE
        DATE(event_start) >= minimum()
        AND DATE(event_end) <= maximum()
        AND lat_mean < 90
        AND lat_mean > -90
        AND lon_mean < 180
        AND lon_mean > -180),

-----------------------------------------------
-- grab daily information on ssvid corresponding to vessel_id 
-----------------------------------------------
    ssvid_map AS (
    SELECT
        vessel_id,
        ssvid
    FROM
        `world-fishing-827.pipe_production_v20201001.vessel_info`),

-----------------------------------------------
-- encounters with ssvid
-----------------------------------------------
 -- Join the encounters data with the ssvid data on the same vessel_id and event day to ensure correct SSVID
    encounter_ssvid AS (
    SELECT * EXCEPT(vessel_id)
    FROM (
    SELECT
    *
    FROM
    encounters) a
    JOIN (
    SELECT *
    FROM
    ssvid_map) b
    ON a.vessel_id = b.vessel_id),

-----------------------------------------------
-- filter encounters by ssvid in vessel_info
-----------------------------------------------
    encounter_ssvid_filtered AS (
    SELECT *
    FROM encounter_ssvid 
    JOIN vessel_info_chitose
        USING(ssvid, year)
    ),

-----------------------------------------------
-- append vessel class info for both encounter vessels
-----------------------------------------------
    vessel_info_all AS (
    SELECT 
        ssvid,
        best.best_vessel_class AS vessel_class,
        on_fishing_list_best
    FROM 
        `world-fishing-827.gfw_research.vi_ssvid_byyear_v20210706`
    WHERE year = 2021
    ),

    -- add vessel info for vessel a
    encounter_ssvid_a AS(
    SELECT * 
    FROM (
        SELECT *
        FROM
        encounter_ssvid_filtered ) a
    JOIN (
        SELECT
        ssvid, 
            vessel_class AS vessel_class_a,
            on_fishing_list_best AS on_fishing_list_best_a
        FROM
        vessel_info_all) b
    ON a.ssvid_a = b.ssvid),

    -- add vessel info for vessel b
    encounter_ssvid_b AS(
    SELECT * 
    FROM (
        SELECT *
        FROM
        encounter_ssvid_a) a
    JOIN (
        SELECT
            ssvid, 
            vessel_class AS vessel_class_b,
            on_fishing_list_best AS on_fishing_list_best_b
        FROM
        vessel_info_all) b
    ON a.ssvid_b = b.ssvid)


-----------------------------------------------
-- return encounter_ssvid_b
-----------------------------------------------
SELECT
*
FROM
encounter_ssvid_b
  "
)

```


```{r}
chitose_enc <- fishwatchr::gfw_query(query = query_6,
                                     run_query = TRUE,
                                     con = con)$data
```
 
Summarise the number of events the Chitose had with 
```{r}
chitose_enc %>% 
  filter(on_fishing_list_best_b == TRUE) %>% 
  summarise(n_events = n_distinct(event_id))
```
My answer: 30
Correct answer: 28 (Hannah used a speed filter < 2 knots)

**QUESTION:** If the only information available is the shipname, what's the best way to query the vessel info tables? Should I query `ais_identity.n_shipname_mostcommon.value` or `ais_identity.n_shipname.value`?
 
## 2. How many loitering events by carriers occurred in IOTC in 2020?
 
```{r}
query_7 <- glue_sql(
  "
-----------------------------------------------
-- Query: How many loitering events by carriers 
-- occurred in IOTC in 2020
-----------------------------------------------

-- Cian Luck, Updated 24 Aug 2021

-- Based on example query loitering_carrier_basic.sql
-- This query finds all carrier vessels with segments that are loitering for at least 4 hours
-- and are at least 20-nm from shore

WITH
-----------------------------------------------
-- Restrict to carrier vessels using the vessel database
-----------------------------------------------
  carrier_vessels as(
    SELECT 
      mmsi AS ssvid,
      year,
      flag,
      vessel_class
    FROM 
    vessel_database.carrier_vessels_byyear_v20210701
    WHERE
    year = 2020
),
-----------------------------------------------
-- Load shapefile of IOTC
-----------------------------------------------
    iotc AS (
    SELECT
    -- note: had to add make_valid => TRUE as seems to be a problem with the shapefile
        ST_GEOGFROMTEXT(string_field_1, make_valid => TRUE) AS polygon 
    FROM
        `world-fishing-827.ocean_shapefiles_all_purpose.IOTC_shape_feb2021`
    ), 

-----------------------------------------------    
-- Filter loitering events to those that are at least 20-nm from shore
-- and are loitering for at least 4 hours
-- Also filter for good segments that are not overlapping and short using gfw_research.pipe_v_segs
-- Adjust desired timeframe
-- Filter only locations within IOTC
-----------------------------------------------
  loitering AS(
  SELECT
    ssvid,
    seg_id,
    loitering_start_timestamp,
    loitering_end_timestamp,
    loitering_hours,
  FROM
    `pipe_production_v20201001.loitering`, iotc
  WHERE
    avg_distance_from_shore_nm >= 20
    AND loitering_hours >= 4
    AND loitering_hours < 24
    AND seg_id IN (
    SELECT
      seg_id
    FROM
      gfw_research.pipe_v20201001_segs
    WHERE
      good_seg
      AND NOT overlapping_and_short)
    AND loitering_start_timestamp >= TIMESTAMP('2020-01-01')
    AND loitering_end_timestamp <= TIMESTAMP('2020-12-31')
    AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(start_lon, start_lat))
    AND ssvid IN (
    SELECT
      ssvid
    FROM
      carrier_vessels))

-----------------------------------------------
-- Return loitering events
-----------------------------------------------     
SELECT
  ssvid,
  seg_id,
  flag,
  loitering_start_timestamp,
  loitering_end_timestamp,
  loitering_hours,
FROM
  loitering
LEFT JOIN
  carrier_vessels
USING
  (ssvid)
ORDER BY
  ssvid,
  seg_id,
  loitering_start_timestamp
  "
)
```
 

```{r}
loitering_iotc <- fishwatchr::gfw_query(query = query_7,
                                        run_query = TRUE,
                                        con = con)$data
```

For some reason the above query returns lots of duplicate rows. Haven't figured out why yet.
The number of non-duplicate loitering events by carriers in the IOTC in 2020 was `r nrow(distinct(loitering_iotc))`` (2921).

## 3. How many of these carriers were authorised by IOTC or CCSBT while loitering?

```{r}
query_8 <- glue_sql(
  "
-----------------------------------------------
-- Query: How many loitering events by carriers 
-- occurred in IOTC in 2020 while authorised
-----------------------------------------------

-- Cian Luck, Updated 24 Aug 2021

-- Based on example query loitering_carrier_basic.sql
-- This query finds all carrier vessels with segments that are loitering for at least 4 hours
-- and are at least 20-nm from shore


---SET your date minimum of interest
CREATE TEMP FUNCTION minimum() AS (DATE('2020-01-01'));
---SET your date maximum of interest
CREATE TEMP FUNCTION maximum() AS (DATE('2020-12-31'));
--SET your year of interest
CREATE TEMP FUNCTION yoi() AS (CAST(2020 AS INT64));



WITH
-----------------------------------------------
-- Restrict to carrier vessels using the vessel database
-----------------------------------------------
  carrier_vessels AS (
  SELECT
    identity.ssvid AS ssvid,
    identity.n_shipname AS shipname,
    identity.flag AS flag_state,
  FROM
    `vessel_database.all_vessels_v20210601`
  LEFT JOIN
    UNNEST(registry)
  LEFT JOIN
    UNNEST(activity)
  WHERE
    is_carrier
    AND confidence >= 3 ),

-----------------------------------------------
-- Load shapefile of IOTC
-----------------------------------------------
    iotc AS (
    SELECT
    -- note: had to add make_valid => TRUE as seems to be a problem with the shapefile
        ST_GEOGFROMTEXT(string_field_1, make_valid => TRUE) AS polygon 
    FROM
        `world-fishing-827.ocean_shapefiles_all_purpose.IOTC_shape_feb2021`
    ), 

-----------------------------------------------    
-- Filter loitering events to those that are at least 20-nm from shore
-- and are loitering for at least 4 hours
-- Also filter for good segments that are not overlapping and short using gfw_research.pipe_v_segs
-- Adjust desired timeframe
-- Filter only locations within IOTC
-----------------------------------------------
  loitering AS(
  SELECT
    ssvid,
    seg_id,
    loitering_start_timestamp,
    loitering_end_timestamp,
    loitering_hours,
  FROM
    `pipe_production_v20201001.loitering`, iotc
  WHERE
    avg_distance_from_shore_nm >= 20
    AND loitering_hours >= 4
    AND seg_id IN (
    SELECT
      seg_id
    FROM
      gfw_research.pipe_v20201001_segs
    WHERE
      good_seg
      AND NOT overlapping_and_short)
    AND loitering_start_timestamp >= TIMESTAMP('2020-01-01')
    AND loitering_end_timestamp <= TIMESTAMP('2020-12-31')
    AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(start_lon, start_lat))
    AND ssvid IN (
    SELECT
      ssvid
    FROM
      carrier_vessels)),

-----------------------------------------------
-- loitering events
-----------------------------------------------     
    loitering_events AS (
    SELECT
        ssvid,
        seg_id,
        shipname,
        flag_state,
        loitering_start_timestamp,
        loitering_end_timestamp,
        loitering_hours,
    FROM
        loitering
    LEFT JOIN
        carrier_vessels
    USING
        (ssvid)
    ORDER BY
        ssvid,
        seg_id,
        loitering_start_timestamp),


-----------------------------------------------
-- which vessels were authorised by IOTC in 2020
-----------------------------------------------  
    iotc_auth_info AS (
    SELECT
    auth_ssvid,
    registry_authorized_to,
    registry_authorized_from,
    reg,
    FROM(
    SELECT
    identity.ssvid as auth_ssvid,
    authorized_to as registry_authorized_to,
    authorized_from as registry_authorized_from,
    is_active as registry_active,
    SAFE_CAST( SPLIT(list_uvi, '-')[OFFSET(0)] AS string) AS reg,
        scraped,
        list_uvi,
    geartype_original as registry_gear,
    feature_gear,
    last_modified
    FROM
    `vessel_database.all_vessels_v20210601`
    LEFT JOIN UNNEST(registry)
    LEFT JOIN UNNEST(activity)
    LEFT JOIN UNNEST(feature.geartype) as feature_gear
    WHERE
    DATE(last_timestamp) >= minimum()
    AND
    DATE(first_timestamp) <= maximum()
    )
    WHERE
    (EXTRACT (YEAR from registry_authorized_to) = yoi()
    OR
    EXTRACT (YEAR from registry_authorized_from) = yoi())
    AND reg = 'IOTC'
    GROUP BY
    auth_ssvid,
    registry_authorized_to,
    registry_authorized_from,
    reg
    ),

-----------------------------------------------
-- which loitering events occurred during authorised periods
----------------------------------------------- 
    loitering_auth AS(
        SELECT * 
        FROM (
        SELECT
        *
        FROM
        loitering_events) a
        JOIN (
        SELECT *
        FROM
        iotc_auth_info ) b
        ON a.ssvid = b.auth_ssvid 
            AND(a.loitering_start_timestamp >= b.registry_authorized_from 
                AND a.loitering_end_timestamp <= b.registry_authorized_to))



-----------------------------------------------
-- Return loitering_auth
-----------------------------------------------  
SELECT *
FROM loitering_auth 
  "
)
```

```{r}
loitering_iotc_auth <- fishwatchr::gfw_query(query = query_8,
                                             run_query = TRUE,
                                             con = con)$data
```

The number of non-duplicate loitering events by carriers in the IOTC in 2020, that were authorised by the IOTC at the time, was `r nrow(distinct(loitering_iotc_autho))`` (814).

## 4. Do the results from 1 or 2 differ from the values shown in the CVP? If so, why?

Answers according to the CVP

Question 1: 102 encounter events (couldn't filter for vessel_class)
Reason: When you hover over 102 "events" this explains that it includes 28 encounters, which is correct
  
Question 2: 2101 loitering events (not sure why less than query estimate)

## 5. How many loitering events that don’t overlap with encounters by the same vessel occur by carriers in IOTC in 2020?

```{r}
query_9 <- glue_sql(
  "
-----------------------------------------------
-- Query: How many loitering events by carriers 
-- occurred in IOTC in 2020, that don't overlap
-- with encounters by the same vessel
-----------------------------------------------

-- Cian Luck, Updated 24 Aug 2021

-- This query aims to pull out encounters and loitering events by carrier vessels
-- and identify the number of loitering events that do NOT overlap with encounters 
-- by the same vessel

-----------------------------------------------
-- Specify date range
-----------------------------------------------
---SET your date minimum of interest
CREATE TEMP FUNCTION minimum() AS (DATE('2020-01-01'));

---SET your date maximum of interest
CREATE TEMP FUNCTION maximum() AS (DATE('2020-12-31'));


WITH

-----------------------------------------------
-- Load shapefile of IOTC
-----------------------------------------------
    iotc AS (
    SELECT
    -- note: had to add make_valid => TRUE as seems to be a problem with the shapefile
        ST_GEOGFROMTEXT(string_field_1, make_valid => TRUE) AS polygon 
    FROM
        `world-fishing-827.ocean_shapefiles_all_purpose.IOTC_shape_feb2021`
    ), 

-----------------------------------------------
-- Restrict to carrier vessels using the vessel database
-----------------------------------------------
  carrier_vessels AS (
  SELECT
    identity.ssvid AS ssvid,
    identity.n_shipname AS shipname,
    identity.flag AS flag_state,
  FROM
    `vessel_database.all_vessels_v20210601`
  LEFT JOIN
    UNNEST(registry)
  -- LEFT JOIN
  --  UNNEST(activity)
  WHERE
    is_carrier
    AND confidence >= 3 ),

-----------------------------------------------
 -- Retrieve initial encounter data, specifing time range and lat/lon
 -- JSON_EXTRACT is used to seperate the listed event_info data of interest into separate columns
 -----------------------------------------------
    encounters AS (
    SELECT
        event_id,
        vessel_id,
        event_start,
        event_end,
        lat_mean,
        lon_mean,
        JSON_EXTRACT(event_info,
        '$.median_distance_km') AS median_distance_km,
        JSON_EXTRACT(event_info,
        '$.median_speed_knots') AS median_speed_knots,
        -- extract the ssvid for both vessels involved in encounter
        JSON_VALUE(event_vessels,
        '$[0].ssvid') AS ssvid_a,
        JSON_VALUE(event_vessels,
        '$[1].ssvid') AS ssvid_b,
    SPLIT(event_id, '.')[ORDINAL(1)] AS event,
    CAST (event_start AS DATE) event_date,
    EXTRACT(YEAR FROM event_start) AS year
    FROM
    `world-fishing-827.pipe_production_v20201001.published_events_encounters`, iotc 
    WHERE
        DATE(event_start) >= minimum()
        AND DATE(event_end) <= maximum()
        -- filter only encounters that occur within the IOTC
        AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(lon_mean, lat_mean))),

-----------------------------------------------
-- grab daily information on ssvid corresponding to vessel_id 
-----------------------------------------------
    ssvid_map AS (
    SELECT
        vessel_id,
        ssvid
    FROM
        `world-fishing-827.pipe_production_v20201001.vessel_info`),

-----------------------------------------------
-- encounters with ssvid
-----------------------------------------------
-- Join the encounters data with the ssvid data on the same vessel_id and event day to ensure correct SSVID
    encounter_ssvid AS (
    SELECT * EXCEPT(vessel_id)
    FROM (
    SELECT
    *
    FROM
    encounters) a
    JOIN (
    SELECT *
    FROM
    ssvid_map) b
    ON a.vessel_id = b.vessel_id),

-----------------------------------------------    
-- Filter loitering events to those that are at least 20-nm from shore
-- and are loitering for at least 4 hours
-- Also filter for good segments that are not overlapping and short using gfw_research.pipe_v_segs
-- Adjust desired timeframe
-- Filter only locations within IOTC
-----------------------------------------------
  loitering AS(
  SELECT
    ssvid,
    seg_id,
    loitering_start_timestamp,
    loitering_end_timestamp,
    loitering_hours,
  FROM
    `pipe_production_v20201001.loitering`, iotc
  WHERE
    avg_distance_from_shore_nm >= 20
    AND loitering_hours >= 4
    AND seg_id IN (
    SELECT
      seg_id
    FROM
      gfw_research.pipe_v20201001_segs
    WHERE
      good_seg
      AND NOT overlapping_and_short)
    AND loitering_start_timestamp >= TIMESTAMP('2020-01-01')
    AND loitering_end_timestamp <= TIMESTAMP('2020-12-31')
    AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(start_lon, start_lat))
    AND ssvid IN (
    SELECT
      ssvid
    FROM
      carrier_vessels)),

-----------------------------------------------
-- loitering events
-----------------------------------------------     
    loitering_events AS (
    SELECT
        ssvid,
        seg_id,
        shipname,
        flag_state,
        loitering_start_timestamp,
        loitering_end_timestamp,
        loitering_hours,
    FROM
        loitering
    LEFT JOIN
        carrier_vessels
    USING
        (ssvid)
    ORDER BY
        ssvid,
        seg_id,
        loitering_start_timestamp),


-----------------------------------------------
-- loitering events without encounters
-----------------------------------------------
-- select only loitering events that do not overlap in time with an encounter event
-- not sure about by conditionals here
    -- loitering_no_encounter AS(
    --     SELECT *
    --     FROM (
    --         SELECT *
    --         FROM loitering_events) a
    --     JOIN (
    --         SELECT *
    --         FROM encounter_ssvid) b
    --     ON a.ssvid = b.ssvid
    --         AND NOT(b.event_start >= a.loitering_start_timestamp
    --                     AND b.event_end <= a.loitering_end_timestamp)
    -- )

    loitering_and_encounter AS(
        SELECT *
        FROM (
            SELECT *
            FROM loitering_events) a
        JOIN (
            SELECT *
            FROM encounter_ssvid) b
        ON a.ssvid = b.ssvid
            AND TIMESTAMP_DIFF(a.loitering_start_timestamp, b.event_start, SECOND) > (3600 * 2)
            AND TIMESTAMP_DIFF(a.loitering_end_timestamp, b.event_end, SECOND) > (3600 * 2)
  	        -- AND (b.event_start >= a.loitering_start_timestamp
                 -- AND b.event_end <= a.loitering_end_timestamp)
    ),

    -- loitering no encounter
    -- this is a defintiely roundabout way to do it. Curious to see how it should be done
    loitering_no_encounter AS(
        SELECT *
        FROM loitering_events 
        WHERE seg_id NOT IN (
            SELECT seg_id
            FROM loitering_and_encounter 
        )
    )



-----------------------------------------------
-- return loitering no encounter
-----------------------------------------------
SELECT *
FROM loitering_no_encounter 


  "
)
```


```{r}
loitering_iotc_no_enc <- fishwatchr::gfw_query(query = query_9,
                                               run_query = TRUE,
                                               con = con)$data
```

The number of loitering events by carriers within the IOTC in 2020 that did not overlap with an encounter was `r nrow(distinct(loitering_iotc_no_enc))` (935).

 
 
 
 
 
 
 
 
