-----------------------------------------------
-- Query: How many loitering events by carriers 
-- occurred in IOTC in 2020, that don't overlap
-- with encounters by the same vessel
-----------------------------------------------

-- Cian Luck, Updated 24 Aug 2021

-- This query aims to pull out encounters and loitering events by carrier vessels
-- and identify the number of loitering events that do NOT overlap with encounters 
-- by the same vessel

-----------------------------------------------
-- Specify date range
-----------------------------------------------
---SET your date minimum of interest
CREATE TEMP FUNCTION minimum() AS (DATE('2020-01-01'));

---SET your date maximum of interest
CREATE TEMP FUNCTION maximum() AS (DATE('2020-12-31'));


WITH

-----------------------------------------------
-- Load shapefile of IOTC
-----------------------------------------------
    iotc AS (
    SELECT
    -- note: had to add make_valid => TRUE as seems to be a problem with the shapefile
        ST_GEOGFROMTEXT(string_field_1, make_valid => TRUE) AS polygon 
    FROM
        `world-fishing-827.ocean_shapefiles_all_purpose.IOTC_shape_feb2021`
    ), 

-----------------------------------------------
-- Restrict to carrier vessels using the vessel database
-----------------------------------------------
  carrier_vessels AS (
  SELECT
    identity.ssvid AS ssvid,
    identity.n_shipname AS shipname,
    identity.flag AS flag_state,
  FROM
    `vessel_database.all_vessels_v20210601`
  LEFT JOIN
    UNNEST(registry)
  -- LEFT JOIN
  --  UNNEST(activity)
  WHERE
    is_carrier
    AND confidence >= 3 ),

-----------------------------------------------
 -- Retrieve initial encounter data, specifing time range and lat/lon
 -- JSON_EXTRACT is used to seperate the listed event_info data of interest into separate columns
 -----------------------------------------------
    encounters AS (
    SELECT
        event_id,
        vessel_id,
        event_start,
        event_end,
        lat_mean,
        lon_mean,
        JSON_EXTRACT(event_info,
        '$.median_distance_km') AS median_distance_km,
        JSON_EXTRACT(event_info,
        '$.median_speed_knots') AS median_speed_knots,
        -- extract the ssvid for both vessels involved in encounter
        JSON_VALUE(event_vessels,
        '$[0].ssvid') AS ssvid_a,
        JSON_VALUE(event_vessels,
        '$[1].ssvid') AS ssvid_b,
    SPLIT(event_id, '.')[ORDINAL(1)] AS event,
    CAST (event_start AS DATE) event_date,
    EXTRACT(YEAR FROM event_start) AS year
    FROM
    `world-fishing-827.pipe_production_v20201001.published_events_encounters`, iotc 
    WHERE
        DATE(event_start) >= minimum()
        AND DATE(event_end) <= maximum()
        -- filter only encounters that occur within the IOTC
        AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(lon_mean, lat_mean))),

-----------------------------------------------
-- grab daily information on ssvid corresponding to vessel_id 
-----------------------------------------------
    ssvid_map AS (
    SELECT
        vessel_id,
        ssvid
    FROM
        `world-fishing-827.pipe_production_v20201001.vessel_info`),

-----------------------------------------------
-- encounters with ssvid
-----------------------------------------------
-- Join the encounters data with the ssvid data on the same vessel_id and event day to ensure correct SSVID
    encounter_ssvid AS (
    SELECT * EXCEPT(vessel_id)
    FROM (
    SELECT
    *
    FROM
    encounters) a
    JOIN (
    SELECT *
    FROM
    ssvid_map) b
    ON a.vessel_id = b.vessel_id),

-----------------------------------------------    
-- Filter loitering events to those that are at least 20-nm from shore
-- and are loitering for at least 4 hours
-- Also filter for good segments that are not overlapping and short using gfw_research.pipe_v_segs
-- Adjust desired timeframe
-- Filter only locations within IOTC
-----------------------------------------------
  loitering AS(
  SELECT
    ssvid,
    seg_id,
    loitering_start_timestamp,
    loitering_end_timestamp,
    loitering_hours,
  FROM
    `pipe_production_v20201001.loitering`, iotc
  WHERE
    avg_distance_from_shore_nm >= 20
    AND loitering_hours >= 4
    AND seg_id IN (
    SELECT
      seg_id
    FROM
      gfw_research.pipe_v20201001_segs
    WHERE
      good_seg
      AND NOT overlapping_and_short)
    AND loitering_start_timestamp >= TIMESTAMP('2020-01-01')
    AND loitering_end_timestamp <= TIMESTAMP('2020-12-31')
    AND ST_CONTAINS(iotc.polygon, ST_GEOGPOINT(start_lon, start_lat))
    AND ssvid IN (
    SELECT
      ssvid
    FROM
      carrier_vessels)),

-----------------------------------------------
-- loitering events
-----------------------------------------------     
    loitering_events AS (
    SELECT
        ssvid,
        seg_id,
        shipname,
        flag_state,
        loitering_start_timestamp,
        loitering_end_timestamp,
        loitering_hours,
    FROM
        loitering
    LEFT JOIN
        carrier_vessels
    USING
        (ssvid)
    ORDER BY
        ssvid,
        seg_id,
        loitering_start_timestamp),


-----------------------------------------------
-- loitering events without encounters
-----------------------------------------------
-- select only loitering events that do not overlap in time with an encounter event
-- not sure about by conditionals here
    -- loitering_no_encounter AS(
    --     SELECT *
    --     FROM (
    --         SELECT *
    --         FROM loitering_events) a
    --     JOIN (
    --         SELECT *
    --         FROM encounter_ssvid) b
    --     ON a.ssvid = b.ssvid
    --         AND NOT(b.event_start >= a.loitering_start_timestamp
    --                     AND b.event_end <= a.loitering_end_timestamp)
    -- )

    loitering_and_encounter AS(
        SELECT *
        FROM (
            SELECT *
            FROM loitering_events) a
        JOIN (
            SELECT *
            FROM encounter_ssvid) b
        ON a.ssvid = b.ssvid
            AND TIMESTAMP_DIFF(a.loitering_start_timestamp, b.event_start, SECOND) > (3600 * 2)
            AND TIMESTAMP_DIFF(a.loitering_end_timestamp, b.event_end, SECOND) > (3600 * 2)
	    -- AND (b.event_start >= a.loitering_start_timestamp
                 -- AND b.event_end <= a.loitering_end_timestamp)	
    ),

    -- loitering no encounter
    -- this is a defintiely roundabout way to do it. Curious to see how it should be done
    loitering_no_encounter AS(
        SELECT *
        FROM loitering_events 
        WHERE seg_id NOT IN (
            SELECT seg_id
            FROM loitering_and_encounter 
        )
    )



-----------------------------------------------
-- return loitering no encounter
-----------------------------------------------
SELECT *
FROM loitering_no_encounter 
